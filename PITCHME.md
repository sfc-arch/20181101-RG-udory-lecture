---?color=linear-gradient(to right, #c02425, #f0cb35)
@title[Introduction]

@snap[west headline text-white span-70]
符号化と復号
@snapend

@snap[south-west byline  text-white]
Arch B4 u-dory
@snapend

---

### 画像を撮って送る

- 様々な符号化処理
  - 読むときは復号

+++

#### 符号化とは？

> 符号理論において、符号（ふごう）またはコード（英: code）とは、シンボルの集合S, Xがあるとき、Sに含まれるシンボルのあらゆる系列から、Xに含まれるシンボルの系列への写像のことである。

@fa[meh-blank] ?????

+++

#### 符号の例

- モールス信号
- DNA
- UTF-8
- ASCII
- JPEG
- 抵抗器のカラーコード

---

### 画像の符号化

<br><br>

- 予測符号化
- 変換符号化
- ベクトル量子化
- エントロピー符号化

エントロピー量子化以外は画像の特徴を見越して行われる。

<br><br>

+++

#### 予測符号化

自然画像は隣接する画素に強い相関がみられることが多い。
したがって画素の情報を直接保存するよりも、
隣接する画素から次の画素の値を予測し、実際の値との差分を保存するほうが効率が良くなる。

- 一次元予測
- 二次元予測
  - 平面予測
  - 平均予測

+++

#### 変換符号化

<br><br>

自然画像は隣接する画素に強い相関が(ry
この特性を活かして画素の行列の変換を行うことで情報量を下げる。

- 離散フーリエ変換
- 離散コサイン変換

<br><br>

+++

#### ベクトル量子化

<br><br>

画像をブロックに分け、それと似たサンプルをコードブックから選び出す。
復元する際はコードブックのサンプルを組み合わせることで近似した画像が得られる。

<br><br>

+++

#### エントロピー符号化

<br><br>

データそのものを数学的に符号化する

- ハフマン符号化
- 算術符号化

<br><br>

---

### 予測符号化


近隣の画素から目的画素の値を予測し、実際の画素の値との差を符号とする方法。

- 一次元予測
  - 前値予測
- 二次元予測
  - 行列予測
  - 平均予測
  - 平面予測

+++

#### 前値予測

<br><br>

`\[
{X = A}
\]`

<br><br>

+++

#### 前値予測(例)

```
 90  90 86 91 101 114 136 136 ...
```

```
(90)  0 -4  5  10   3  22   0 ...
```

+++

#### 行列予測

<br><br>

`\[
 X = { (A + C) \over 2 }
\]`

<br><br>

+++

#### 行列予測(例)

```
 90  90 86 91 101 114 136 136 ...
 89  88 88 92  99 108 131 139 ..
```

```
(90)  0 -4  5  10   3  22   0 ...
 89  -1  1  3   3   2   9   6 ...
```

+++

#### 平面予測

<br><br>

`\[
 X = { A - B + C }
\]`

<br><br>

+++

#### フレーム間予測

動画では前後の画像の画素とも相関性がある。
これも予測に用いることができる。

---

### (直交)変換符号化

前置予測でも触れたように、

`\[
{X = A}
\]`

という予測が成立する。

+++

#### (直交)変換符号化

このとき任意の画素 `\( X_1 \)` とその右隣の画素 `\( X_2 \)` において

`\[
  X_1 \simeq X_2
\]`

である。つまり、 `\( X_1 \)` , `\( X_2 \)` を軸にとった座標を取り、
各点について `\(　\left( X_N , X_N+1 \right) \)` をプロットすると、
`\[ X_1 = X_2 \]` 
付近に点が集まる。

+++

#### (直交)変換符号化

(ここでグラフのイメージ)

+++

#### (直交)変換符号化

プロットが軸の付近に集まる  
  ＝偏りを持ったデータ
→ 情報量 少

+++

#### (直交)変換符号化

- 画像ごとに最適な回転行列が異なる
  - 都度求めるのと最大圧縮
  - → カルーネン・レーベン変換
- 自然画では **離散コサイン変換** (DCT) が近似的
  - JPEGはイラストなどが苦手

+++

#### JPEGでのDCTとMCU

- Minimum Coded Unit (MCU)
  - 画像をブロックで扱う際の単位
  - JPEG: 8x8

(ここでDCTの結果のサンプル)

---

### エントロピー符号化

符号のうち、

- 情報源のシンボルの出現確率に応じた符号語
- 長さの異なる符号語を使用
- 情報源を効率的に符号化

ハフマン符号や算術符号など

+++

#### エントロピー理論値

`\[
\sum \left( -P(X) \cdot \log_2 P(X) \right) \\
 \verb|where|　 P(X) = 配列中のXの出現確率
\]`

`a`が99コ、`b`が1コ出現する情報源ならば

`\[
-0.99 \cdot log_2{0.99} -0.01 \cdot log_2{0.01} \\
　　\simeq 0.0808
\]`

一文字あたりのエントロピーが0.08なので、100文字で8ビットまで理論上圧縮できる。

---

### ハフマン符号

- パテントフリー
- 高効率
- HTTP2ヘッダーで利用される
- スキャン必要
- 出現順に符号を与える
- ハフマン木
  - 出現率低い順
- 符号表が必要

+++

#### ハフマン符号　１

情報源「`a b a c a b`」を圧縮することを考える

まずは出現回数を調べる。

|   | a | b | c |
|---|:---:|:---:|:---:|
|出現数|3|2|1|
|出現確率|`$ 1 \over 2 $`|`$ 1 \over 3 $`|`$ 1 \over 6 $`|

+++

この場合、エントロピーは


`\[
-{1 \over 2} \cdot log_2{1 \over 2} - {1 \over 3} \cdot log_2{1 \over 3} -{1 \over 6} \cdot log_2{1 \over 6} \\
　　\simeq 1.459
\]`

なので、全体は９ビットで表現できることに

+++

#### ハフマン符号　２

次にハフマン木を作成。

1. 出現文字で２分木を組み上げる
  - 出現頻度の低い２文字を一番下の分岐として下から
1. 各分岐で出現頻度の高い方に「`1`」を、低い方に「`2`」を割り当てる
1. 各分岐で割り振られた符号をつなげたものがその文字の符号

+++

これにより

```
a : 0
b : 10
c : 11
```

なので、

```
a b a c a b => 010011010   # 9bits!
```


---

### 算術記号

- 一番効率の良いエントロピー符号化法
  - ハフマン符号は効率が良いが、†最強†ではない

- 数直線を各文字の出現割合に分割
  - 再帰的に進める
    - そのうち文字列の出現確率が出てくる
  - その数値が符号になる


---

### 動的符号化

- ハフマンも算術も静的
  - 符号化前にファイル全体を読む必要がある
- ASCIIも静的
  - 英字は文字が少ない

---

### 適応型ハフマン符号

- ファイルを読みながら木を作成
  - 現れた新記号を木に追加する

---

### FGK符号化

- 適応型ハフマン符号の弱点の克服したい
  - 木を何度も作り直すのは遅い

+++

#### 兄弟条件

> 全ての節は必ず二つの子を持ち、それぞれに重みの小さい順に番号を付けたとき、二つの子の番号は連続しており、且つ親の節の番号は子の節の番号よりも大きくなる

- ハフマン木の成り立つ必要十分条件
  - これを達成すればハフマン木になる
- 重み＝出現回数

#### FGK符号化の流れ


1.  重さ 0、通し番号 1 の節 ( 0-node ) のみを持つハフマン木を作成する。
2.  データを一つ読み込み x とする。
3.  x が初めて出現したものならば、現在の 0-node の左側に新たな 0-node を、右側に x を持つ葉 p を追加して、重みの小さい順に通し番号を付け直す。この時、必ず一つの節にぶら下がっている二つの子が連続した番号を持つようにする。
4.  p が持つ符号を出力する。初めて出現したデータであった場合は、データそのものをさらに出力する。
5.  p の重みと等しい節の中から、番号の最も大きいものを探す。もし見つかったら、二つを部分木ごと交換して、通し番号を付け直す。
6.  p の重みに 1 を加える。
7.  親の節をたどって、根に到達するまで 5 から 6 までを繰り返す。
8.  データを全て読み込むまで、2 から 7 までを繰り返す。 